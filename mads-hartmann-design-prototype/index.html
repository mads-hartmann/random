<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Automating Developer Environments</title>
  <link href="https://fonts.googleapis.com/css?family=Muli:200,200i,400,400i,700,700i" rel="stylesheet">
  <link rel="stylesheet" href="index.css">
</head>

<body>
  <div class="container">

    <div class="menu">
      <a href="#">
        <img src="http://mads-hartmann.com/images/me-v2-square.jpg" width="45" height="45" />
        Mads Hartmann
      </a>
      <ul>
        <li>posts</li>
        <li>talks</li>
      </ul>
    </div>

    <div class="appetizer">
      <p>
        Recently I've been thinking about what the ideal developer environment looks like to me and tried to implement some of those
        thoughts at <a href="https://famly.co">Famly</a>. I don't mean developer environment in the sense of an IDE but
        rather the set of tools and services you are running in order to develop on your various projects. If you're working
        on a backend that might be
        <a href="https://www.postgresql.org/">Postgres</a>, <a href="https://redis.io/">Redis</a>, and your backend. To me
        this is your developer environment; the developer environment is agnostic to what tools you use to manipulate the source
        code.
      </p>
      <p>
        I've seen a lot of blog posts and conference talks about automating your deployments but I haven't seen much about automating
        your developer environment. In this post I'll go through what we're trying to achieve at Famly and give some details
        about the implementation.
      </p>
    </div>

    <div class="title">
      <h1>
        Automating Developer Environments
      </h1>
      <section class="meta">
        <a href="/">Mads Hartmann</a> - 15 Jan 2017
      </section>
    </div>
    <p>
      To me the ultimate developer environment is one that takes zero effort to setup and once it's running gets out of your way.
      The developer should be able to focus on the task at hand rather than the mechanics of the developer environment.
    </p>
    <p>
      This is of course rather abstract, so here are some very concrete goals.
    </p>
    <ul class="org-ul">
      <li><b>Setup should be 100% automated</b>: The developer shouldn't have to wade though several READMEs in order to get
        things running (assuming READMEs exists). If you can put it in a README it's likely you can automate it as well.
      </li>

      <li><b>Observing your changes should be automatic</b>: Whenever you change the source code of a given service it should
        detect it and take whatever steps are necessary for you to observe those changes. If you're working on the frontend
        this means recompiling and refreshing the browser (or ideally, hot-reload the changed module). The same goes if you're
        working on the backend; recompiling and restarting the server shouldn't be a manual task.
      </li>

      <li><b>Running everything locally should be possible (and trivial), but
optional</b>: This is somewhat implied by the previous bullet – you can't observe your changes if you aren't running the
        service locally. But this also goes for services you have no intention of changing, that is, if you're exclusively
        working on the frontend you might still want to run the backend(s) locally simply to have your own dataset and ensure
        that if somehow your staging environment breaks you can still work on your feature. Other times you won't care and
        it will be easier to work against the staging environment. It should be trivial to change between the two.
      </li>
    </ul>
    <p>
      This is a rather tall order, but I think we've come pretty close at Famly. There are two parts to the solution. We've decided
      to rely on Docker to run services locally, so for each service we've defined a specialized Dockerfile for running the
      service during development. Secondly we've created a script, <code>famlydev</code>, for managing the local developer
      environment. First off I'll introduce <code>famlydev</code> and then I'll show the patterns we've arrived at for creating
      Docker images that work well for development.
    </p>
    <p>
      We decided to create a single Git repository that contains all of our code related to managing the developer environment.
      This repository is the main entrypoint for developers and it takes care of setting up the developer environment, as
      well as managing it once it's running.
    </p>
    <a href="/images/famlydev.png">
    <img src="http://mads-hartmann.com/images/famlydev.png" width="100%">
</a>
    <p>
      It consists of a rather small <a href="http://mads-hartmann.com/2016/08/20/make.html">Makefile</a>, a collection of
      Bash scripts, and a very small README. The Makefile take care of cloning the relevant Famly repositories, installing
      various system dependencies (such as Docker and the docker-rsync gem) as well as installing our home-grown <code>famlydev</code>      script which is the developers interface to the developer environment. It also knows when to rebuild the various Docker
      images. This is how we've achieved the <b>100% automated setup</b>.
    </p>
    <p>
      The repository also contains a collection of <code>docker-compose.yml</code> definitions. Currently we have one for
      each common use-case and you can switch between them using <code>famlydev switch
fullstack|frontend|backend</code>. This is how we've made it <b>optional to
run some services locally</b>. For now having these predefined configurations works well for us but I can imagine that in
      the future we'll want to make it easier to pick and chose which services to run.
    </p>
    <p>
      I think having a script like <code>famlydev</code> is a crucial part of creating a great automated development environment.
      It also makes it easy to share automated work-flows. As an example, the other day my coworker
      <a href="https://twitter.com/Chr_Harrington">Christian</a> added a new command <code>db</code> which for now has one
      use-case,
      <code>famlydev db regen</code>, which will nuke the current database and re-run migrations to provide a clean database.
      To make <code>famlydev</code> easier and more enjoyable to use we've implemented context-sensitive tab-completion (just
      for ZSH for now) – that is <code>famlydev kick &lt;tab&gt;</code> will tab-complete based on the services you have
      running – and you can get more information about each command using <code>famlydev help
&lt;command&gt;</code>.
    </p>







    <p>
      For each service we've created a <a href="https://docs.docker.com/engine/reference/builder/">Dockerfile</a>. These
      Dockerfiles are slightly different from ones you would normally create for a production environment. They only install
      the required system libraries and don't contain any of the source code or library dependencies (though we do warm-up
      the relevant caches so you don't have to wait for <code>yarn</code>, or similar tools, to finish downloading whenever
      you boot the service). The images are empty shells that only work if you mount in the source code from the host – I'll
      get to why we've chosen this approach later.
    </p>

    <p>
      Each service has an <a href="https://docs.docker.com/engine/reference/builder/#/entrypoint">entrypoint</a> script which
      generally follow the same structure.
    </p>

    <ul class="org-ul">
      <li>Install library dependencies (e.g. <code>yarn install</code> for the frontend)
      </li>

      <li>Start the service in the background (For our PHP code that would be Apache). This service should know how to react
        to changes to the source code.
      </li>

      <li>Detect if a configuration (like <code>package.json</code> or <code>composer.json</code>) file changes (detected using
        <a href="http://man7.org/linux/man-pages/man7/inotify.7.html">inotify</a>) or a <a href="https://en.wikipedia.org/wiki/Unix_signal#SIGHUP">SIGHUP</a>        signal is sent and then re-install library dependencies and restart the service. The
        <code>SIGHUP</code> signal enables us to use <code>famlydev kick &lt;service&gt;</code> if a service gets stuck for
        one reason or another.
      </li>
    </ul>

    <p>
      This approach is working nicely for us. The advantage of not having baked very much into the images is that we can re-use
      a running container in many different environments. For example you can switch between the master and staging branches
      and the container will perform the necessary steps. This means that for the most part you don't worry about the containers.
      You simply run <code>famlydev up</code> in the morning and
      <code>famlydev down</code> when you leave. You can keep switching branches, adding library dependencies or changing
      the source code as you always have.
    </p>









    <p>
      The current state of <code>famlydev</code> is the result of roughly 2 months of experimenting with various solutions.
      So far I'm happy with the approach of using Make for setup and dependency tracking, docker-compose for configuring
      which services to run, and Bash for providing the developer with an enjoyable CLI.
    </p>

    <p>
      I have no doubt that over the next couple of months we'll continue to improve it and try out new things. I'll keep you posted.
      If you've done something similar, or solved the same problems in a different way I'd love to hear about it.
    </p>
  </div>
</body>

</html>
